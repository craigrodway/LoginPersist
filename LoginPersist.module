<?php

namespace ProcessWire;

/**
 * Persistent logins for users.
 *
 * This module supports the functionality that allow users to persist their login
 * to the site across browser sessions, and follows industry best practise.
 *
 * @copyright Copyright (C) 2014, Craig A Rodway <craig.rodway@gmail.com>
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2
 *
 */

class LoginPersist extends WireData implements Module, ConfigurableModule
{


	/**
	 * Configuration
	 *
	 */
	public static function getModuleInfo() {
		return array(
			'title' => 'Persistent Login for users.',
			'version' => '1.0.0',
			'summary' => 'Providing "Stay logged in" functionality for users across browser sessions.',
			'href' => 'https://github.com/craigrodway/LoginPersist',
			'singular' => true,
			'autoload' => true,
		);

	}


	protected static $dbTable = 'login_persist';


	protected static $defaultSettings = array(

		// persist logins for all users automatically
		'automatic' => 1,

		// check the user agent string + IP address as well as cookie data
		'useFingerprint' => 1,

		// an identifier set to true in the session when a persistent login was used
		'persistentId' => 'persistent',

		// how long the cookie will last, in days
		'cookieExpires' => 7,

		// name ot use for persistent cookie
		'cookieName' => 'persist',

		// Valid users roles who can be given persistent logins
		'roles' => array(),
	);


	public function __construct() {
		foreach (self::$defaultSettings as $key => $value) {
			$this->set($key, $value);
		}
	}


	/**
	 * Module configuration.
	 *
	 * @param array $data Module data from the database.
	 *
	 */
	public static function getModuleConfigInputfields(array $data) {

		$fields = new InputfieldWrapper();

		foreach (self::$defaultSettings as $key => $value) {
			if ( ! isset($data[$key])) $data[$key] = $value;
		}

		$f = wire('modules')->get('InputfieldCheckbox');
		$f->columnWidth = 50;
		$f->attr('name', 'automatic');
		$f->attr('value', 1);
		$f->attr('checked', $data['automatic'] ? 'checked' : '');
		$f->label = __('Automatic');
		$f->description = __('Persist logins automatically for all users. No code changes required, but does not give users any choice.');
		$fields->add($f);

		$f = wire('modules')->get('InputfieldCheckbox');
		$f->columnWidth = 50;
		$f->attr('name', 'useFingerprint');
		$f->attr('value', 1);
		$f->attr('checked', $data['useFingerprint'] ? 'checked' : '');
		$f->label = __('Use fingerprint');
		$f->description = __('Check User Agent and/or IP address. This uses the site configuration value for `$config->sessionFingerprint`.');
		$fields->add($f);

		$f = wire('modules')->get('InputfieldText');
		$f->columnWidth = 30;
		$f->attr('name', 'cookieName');
		$f->attr('value', $data['cookieName']);
		$f->attr('size', 20);
		$f->attr('maxlength', 32);
		$f->label = __('Cookie name');
		$f->description = __('Specify the name of the cookie that is given to users.');
		$fields->add($f);

		$f = wire('modules')->get('InputfieldText');
		$f->columnWidth = 35;
		$f->attr('name', 'cookieExpires');
		$f->attr('value', $data['cookieExpires']);
		$f->attr('size', 5);
		$f->attr('maxlength', 3);
		$f->label = __('Cookie length');
		$f->description = __('Number of days the persistent cookie will last. As long as the user visits again within this period, their login will remain persistent.');
		$fields->add($f);

		$f = wire('modules')->get('InputfieldText');
		$f->columnWidth = 35;
		$f->attr('name', 'persistentId');
		$f->attr('value', $data['persistentId']);
		$f->attr('size', 20);
		$f->attr('maxlength', 32);
		$f->label = __('Persistent session identifier');
		$f->description = __("When a user is logged in via a persistent cookie, this session variable is set to `true`. Use this within your own code to prevent access to sensitive information or actions. E.g. `\$this->wire('session')->get('persistent'); // true`");
		$fields->add($f);

		$f = wire('modules')->get('InputfieldAsmSelect');
		$f->attr('name', 'roles');
		foreach (wire('pages')->find('template=role, sort=name') as $role) {
			if ($role->name == 'guest') continue;
			$f->addOption($role->name, $role->name);
		}
		$f->attr('value', $data['roles']);
		$f->label = __('Valid roles');
		$f->description = __('Persistent logins will be given to users with these roles. Leave empty to allow any user to receive persistent logins.');
		$fields->append($f);

		if (wire('input')->post('clearLogins')) {
			$query = wire('database')->prepare('DELETE FROM `' . self::$dbTable . '`');
			$query->execute();
			wire('modules')->message(__('Cleared persistent logins.'));
		} else {
			$result = wire('db')->query('SELECT COUNT(*) FROM `' . self::$dbTable . '`');
			list($n) = $result->fetch_row();
			$f = wire('modules')->get('InputfieldCheckbox');
			$f->attr('name', 'clearLogins');
			$f->attr('value', 1);
			$f->label = __('Clear persistent logins?');
			$f->description = __('This will clear out all persistent login database entries. Users with login cookies will have to log in manually on their next visit.');
			$f->notes = sprintf(__('There are currently %d persistent logins.'), $n);
			$fields->add($f);
		}

		return $fields;
	}


	/**
	 * Initialise hooks, housekeeping, and try cookie logins.
	 *
	 */
	public function init() {
		$this->set('doLoginHook', true);
		$this->session->addHookAfter('loginSuccess', $this, 'hookLoggedIn');
		$this->session->addHookAfter('logoutSuccess', $this, 'hookLoggedOut');
		$this->session->addHook('keepLoggedIn', $this, 'hookKeepLoggedIn');
		$this->pruneLogins();
		$this->attemptLogin();
	}


	/**
	 * Hook for session()->login: A user has successfully logged in.
	 * Persist the login if automatic option is turned on.
	 *
	 */
	public function hookLoggedIn() {
		// Check if logins should be persisted for all users automatically
		if ($this->automatic && $this->doLoginHook) {
			$this->persist();
		}
	}


	/**
	 * Hook for session()->logout: User has logged out.
	 * Clear database entries and their cookie.
	 *
	 */
	public function hookLoggedOut() {

		// Get info from current cookie so the database entry can be deleted
		$cookie = $this->parseCookie();

		if ($cookie) {

			// Remove DB entries

			$sql = 'DELETE FROM `' . self::$dbTable . '`
					WHERE user = :user AND series = :series
					LIMIT 1';

			$database = $this->wire('database');
			$query = $database->prepare($sql);
			$query->bindValue(":user", $cookie->user, \PDO::PARAM_INT);
			$query->bindValue(":series", $cookie->series, \PDO::PARAM_STR);
			$query->execute();
		}

		// Clear their cookie
		setcookie($this->get('cookieName'), '', time() - 42000, '/');
	}


	public function hookKeepLoggedIn() {
		$this->persist();
	}


	/**
	 * Persist login for current user
	 *
	 * @param string $series        Existing series (If regenerating from current autologin)
	 *
	 */
	public function persist($series = false) {

		$user = $this->wire('user');
		$database = $this->wire('database');
		$time = time();
		$fingerprint = $this->wire('session')->getFingerprint();

		// Don't persist logins for guest user
		if ($user->isGuest()) {
			return false;
		}

		// Ensure the user's roles are valid
		if ( ! $this->checkRoles($user)) {
			return false;
		}

		// Generate a new pair of tokens as they will always be needed
		list ($public, $private) = $this->generateKeys();

		if ( ! $series) {

			// No series was present. We are creating a new persistent login for the user.

			// Generate a new string for the series (first param is the hashed random part)
			list ($series) = $this->generateKeys();

			$sql = 'INSERT INTO
						`' . self::$dbTable . '`
					SET
						user = :user,
						series = :series,
						token = :token,
						fingerprint = :fingerprint,
						created = :time
					';

			$query = $database->prepare($sql);
			$query->bindValue(":user", $user->id, \PDO::PARAM_INT);
			$query->bindValue(":series", $series, \PDO::PARAM_STR);
			$query->bindValue(":token", $private, \PDO::PARAM_STR);
			$query->bindValue(":fingerprint", $fingerprint, \PDO::PARAM_STR);
			$query->bindValue(":time", $time, \PDO::PARAM_INT);
			$query->execute();

		} else {

			// Got a series from an existing login. We just need to update existing series.
			$sql = 'UPDATE
						`' . self::$dbTable . '`
					SET
						token = :token,
						fingerprint = :fingerprint,
						created = :time
					WHERE user = :user
					AND series = :series
					LIMIT 1';

			$query = $database->prepare($sql);
			$query->bindValue(":token", $private, \PDO::PARAM_STR);
			$query->bindValue(":fingerprint", $fingerprint, \PDO::PARAM_STR);
			$query->bindValue(":time", $time, \PDO::PARAM_INT);
			$query->bindValue(":user", $user->id, \PDO::PARAM_INT);
			$query->bindValue(":series", $series, \PDO::PARAM_STR);
			$query->execute();
		}

		// Finally set cookie

		$value = implode(':', array($user->id, $series, $public));

		$expires = (int) $this->get('cookieExpires');
		$expires = strtotime("+{$expires} days");

		setcookie($this->get('cookieName'), $value, $expires, '/', null, false, true);
	}


	/**
	 * Make a persistent login attempt by checking cookie.
	 *
	 */
	public function attemptLogin() {

		// Do not continue if user is not a guest (a user is already logged in)
		if ( ! $this->wire('user')->isGuest()) {
			return false;
		}

		$database = $this->wire('database');
		$fingerprint = $this->wire('session')->getFingerprint();
		$cookie = $this->parseCookie();

		if ( ! $cookie) {
			return false;
		}

		// Get matching DB entry
		$sql = 'SELECT * FROM `' . self::$dbTable . '`
				WHERE user = :user AND series = :series
				LIMIT 1';

		$query = $database->prepare($sql);
		$query->bindValue(":user", $cookie->user, \PDO::PARAM_INT);
		$query->bindValue(":series", $cookie->series, \PDO::PARAM_INT);
		$query->execute();
		$numRows = $query->rowCount();

		if ( ! $numRows) {
			// Got cookie data, but no matching database entry
			// Clear the cookie
			setcookie($this->get('cookieName'), '', time() - 42000, '/');
			return false;
		}

		$row = $query->fetch(\PDO::FETCH_OBJ);

		if ( ! $this->validateKeys($cookie->key, $row->token)) {
			// Key matching failure. Invalidate all user's persistent login data
			$this->destroyLogins($cookie->user);
		}

		// Success!
		//

		// Do a fingerprint check
		if ($this->useFingerprint && $row->fingerprint !== $fingerprint) {
			// We are using fingerprint for additional check but it failed
			$this->destroyLogins($cookie->user);
			return false;
		}

		// Get the user and log them in
		$u = $this->wire('users')->get('id=' . $cookie->user);
		if ( ! $u->id) {
			return false;
		}

		// Ensure the user's roles are valid
		if ( ! $this->checkRoles($u)) {
			return false;
		}

		// Our loginSuccess hook could call persist().
		// We don't want that to run in this secnario:
		// Specify a flag so the login hook does not run.
		$this->doLoginHook = false;

		// Force user login
		$this->wire('session')->forceLogin($u);

		// Set the session persistent identifier
		$this->wire('session')->set($this->get('persistentId'), true);

		// Create new persistent login with the existing series
		$this->persist($cookie->series);
	}


	/**
	 * Remove all persistent logins for the specified user
	 *
	 * @param string|User $user ID or User object
	 * @return void
	 *
	 */
	public function destroyLogins($user) {

		$database = $this->wire('database');

		$sql = 'DELETE FROM `' . self::$dbTable . '`
				WHERE user = :user';

		if (is_object($user) && $user instanceof User) {
			$id = $user->id;
		} else {
			$id = (int) $user;
		}

		$query = $database->prepare($sql);
		$query->bindValue(":user", $id, \PDO::PARAM_INT);
		$query->execute();
	}


	/**
	 * Check if a user's roles are permitted to use persistent logins.
	 *
	 * @param string|User $user ID or User object
	 * @return bool
	 *
	 */
	public function checkRoles($user) {

		$roles = $this->get('roles');
		if (empty($this->roles)) {
			return true;
		}

		$isUser = (is_object($user) && $user instanceof User);
		if ( ! $isUser) {
			$user = $this->wire('users')->get('id=' . (int) $user);
		}

		foreach ($this->roles as $role) {
			if ($user->hasRole($role)) {
				return true;
			}
		}

		return false;
	}


	/**
	 * Remove persistent login entries from the database that have expired.
	 *
	 * @return void
	 *
	 */
	private function pruneLogins() {

		$database = $this->wire('database');

		$expires = (int) $this->get('cookieExpires');
		$expires = strtotime("-{$expires} days");

		$sql = 'DELETE FROM `' . self::$dbTable . '` WHERE created <= :time';

		$query = $database->prepare($sql);
		$query->bindValue(":time", $expires, \PDO::PARAM_INT);
		$query->execute();
	}


	/**
	 * Generate a pair of keys
	 *
	 * @return array 2D array with two values: public and private keys
	 *
	 */
	private function generateKeys() {
		$hash_algo = $this->wire('config')->userAuthHashType;
		$salt = (string) $this->wire('config')->userAuthSalt;
		$public = hash($hash_algo, uniqid(rand()));
		$private = hash_hmac($hash_algo, $public, $salt);
		return array($public, $private);
	}


	/**
	 * Validate a key pair.
	 *
	 * @param string $public Public part of key.
	 * @param string $private Private part of key.
	 * @return bool
	 *
	 */
	private function validateKeys($public = '', $private = '') {
		$hash_algo = $this->wire('config')->userAuthHashType;
		$salt = (string) $this->wire('config')->userAuthSalt;
		$check = hash_hmac($hash_algo, $public, $salt);
		return $check === $private;
	}


	/**
	 * Parse the stored cookie and return an object containing the data.
	 * If the cookie can't be read or doesn't contain the constituent parts, return value is false.
	 *
	 * @return object|boolean
	 *
	 */
	private function parseCookie() {

		$raw_cookie = $this->wire('input')->cookie($this->get('cookieName'));

		if ( ! $raw_cookie) {
			return false;
		}

		// Yep.
		list ($user, $series, $key) = explode(':', $raw_cookie);

		// Package it up nicely
		if ($user && $series && $key) {
			$cookie = new WireData();
			$cookie->user = $user;
			$cookie->series = $series;
			$cookie->key = $key;
			return $cookie;
		} else {
			return false;
		}
	}


	/**
	 * Install: create database table.
	 *
	 */
	public function ___install() {

		$sql =  "CREATE TABLE `" . self::$dbTable . "` (
					`user` int(10) unsigned NOT NULL,
					`series` char(64) NOT NULL,
					`token` char(64) NOT NULL,
					`fingerprint` varchar(255) NOT NULL,
					`created` int(11) unsigned NOT NULL,
					PRIMARY KEY (`user`, `series`)
				);";

		$this->database->exec($sql);
	}


	/**
	 * Uninstall. Removes database table.
	 *
	 */
	public function ___uninstall() {
		$this->database->exec("DROP TABLE IF EXISTS `" . self::$dbTable . "`");
	}


}
